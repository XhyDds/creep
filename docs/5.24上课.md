原子访存	单核不用记地址	一直做的时候若中断	也会触发访存相关异常	LLbit若为0则不触发异常

PRELD	可以当nop	但是不能触发异常

CACOP	对应操作数二级若未实现可以当nop	（实现了也许可以当nop

特权寄存器等高位可不实现

中断源注意优先级和记录

中断响应阶段	提交阶段真正响应中断	

助教队设计为decode阶段标记中断，flush中间的指令：为什么在decode标记？ 在之后标记可能会有后来的指令产生了错误的stall和cache未命中。意思就是不能让之后的指令产生不可逆的修改，直接flush就完了。	

外设中断的记录寄存器，在中断程序中会由软件清除，硬件不负责

先处理最后阶段的异常（最先提交的指令的异常）

手册有优先级（针对同一条指令的不同阶段异常）

中断和例外是类似的设计

用户程序访问地址之外是访存地址错误（针对虚拟地址），非对齐就是非对齐。

中断产生时候无所谓前一个周期后一个周期，如果有一些奇怪的指令我们不让他带中断标记，放到下一条指令带中断去执行。并且中断必定回来，所以指令一定都被执行了。

下一周任务：中断和异常搞清楚、存储器管理。

译码：助教队：对于所有的指令直接比较，产生一个比较长的位向量，合法就只有一个1。张老师：最高6位先看，再看后面的位	（case里面套case）。或者对于三段opcode并行译码。就是空间换时间问题，到时候再讨论。

​     

